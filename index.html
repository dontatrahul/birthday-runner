<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Birthday Runner ðŸŽ‚</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
  
  :root {
    --bg: #2c3e50;
    --surface: #34495e;
    --primary: #3498db;
    --secondary: #2ecc71;
    --accent: #f39c12;
    --text: #ffffff;
    --text-muted: #bdc3c7;
    --success: #27ae60;
    --shadow: rgba(0, 0, 0, 0.3);
    --glow: rgba(52, 152, 219, 0.3);
  }
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: linear-gradient(135deg, #34495e 0%, #2c3e50 50%, #1a252f 100%);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    margin: 0;
    padding: 20px;
  }
  
  .game-wrapper {
    position: relative;
    padding: 2rem;
    max-width: 1200px;
    width: 100%;
  }
  
  .header {
    text-align: center;
    margin-bottom: 2rem;
    z-index: 10;
    position: relative;
  }
  
  .title {
    font-size: 3.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, #3498db, #f39c12, #2ecc71);
    background-size: 200% 200%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: gradient 4s ease-in-out infinite;
    margin-bottom: 0.5rem;
    letter-spacing: -0.02em;
  }
  
  .subtitle {
    font-size: 1.25rem;
    color: rgba(255, 255, 255, 0.8);
    font-weight: 400;
    letter-spacing: 0.01em;
  }
  
  @keyframes gradient {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }
  
  .game-container {
    position: relative;
    border-radius: 20px;
    overflow: hidden;
    box-shadow: 
      0 25px 50px rgba(0, 0, 0, 0.25),
      0 0 0 1px rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  canvas {
    display: block;
    width: 100%;
    height: auto;
    background: linear-gradient(180deg, #7fb3d3 0%, #5dade2 50%, #a8e6cf 100%);
  }
  
  .hud {
    position: absolute;
    top: 15px;
    right: 15px;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    padding: 12px 16px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    font-weight: 500;
    font-size: 0.8rem;
    min-width: 140px;
    max-width: 160px;
  }
  
  .hud-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
  }
  
  .hud-item:last-child {
    margin-bottom: 0;
  }
  
  .hud-value {
    color: #3498db;
    font-weight: 600;
  }
  
  .floating-particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }
  
  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    animation: float 8s linear infinite;
  }
  
  @keyframes float {
    0% {
      transform: translateY(100vh) translateX(-50px);
      opacity: 0;
    }
    10% {
      opacity: 1;
    }
    90% {
      opacity: 1;
    }
    100% {
      transform: translateY(-100px) translateX(50px);
      opacity: 0;
    }
  }
  
  .controls-hint {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.875rem;
    font-weight: 400;
  }
  
  @media (max-width: 768px) {
    .game-wrapper {
      padding: 1rem;
    }
    
    .title {
      font-size: 2.5rem;
    }
    
    .subtitle {
      font-size: 1rem;
    }
    
    .hud {
      top: 10px;
      right: 10px;
      padding: 0.75rem 1rem;
      font-size: 0.75rem;
      min-width: 150px;
    }
    
    .controls-hint {
      bottom: 10px;
      left: 10px;
      font-size: 0.75rem;
    }
  }
</style>
</head>
<body>
  <div class="floating-particles"></div>
  
  <div class="game-wrapper">
    <div class="header">
      <h1 class="title">SanTEAgo is a Track Star!</h1>
      
    </div>
    
    <div class="game-container">
      <canvas id="game" width="1000" height="400"></canvas>
      
      <div class="hud" id="hud">
        <div class="hud-item">
          <span>Status</span>
          <span class="hud-value" id="status">Ready to Play</span>
        </div>
        <div class="hud-item">
          <span>Progress</span>
          <span class="hud-value" id="progress">0%</span>
        </div>
        <div class="hud-item">
          <span>Score</span>
          <span class="hud-value" id="score">0</span>
        </div>
      </div>
      
      <div class="controls-hint" id="controls">
        Press SPACE or tap to jump
      </div>
    </div>
  </div>

<script>
/*
  >>> PNG Image Instructions <<<
  Place these PNG files in the same folder as this HTML file:
  - player.png    (main character - recommended size: 60x60px)
  - partner.png   (celebration character - recommended size: 60x60px)
  - gift.png      (optional gift box - recommended size: 80x80px)
*/

const BIRTHDAY_MESSAGE = "HAAPPYYYY BIRTHDAYYYYYY RESHMAAAAA!! Beyond grateful that our friendship found its way back. You mean so so much to me. Incredibly proud of the person youâ€™re becoming, and I hope today is LEGEN â€” wait for it â€” DARY!";

// Load PNG images
const playerImg = new Image();
const partnerImg = new Image();
const giftImg = new Image();

playerImg.src = "player.png";
partnerImg.src = "partner.png";
giftImg.src = "gift.png";

// Game setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;
const GROUND_Y = 320;

// Modern subtle color palette
const colors = {
  sky: '#7fb3d3',
  skyBottom: '#a8e6cf',
  ground: '#95a5a6',
  groundDark: '#7f8c8d',
  player: '#3498db',
  partner: '#2ecc71',
  accent: '#f39c12',
  white: '#ffffff',
  dark: '#2c3e50',
  obstacle: '#e74c3c'
};

// Game state
let gameState = {
  current: 'start', // start, playing, gameover, celebration, message
  score: 0,
  progress: 0,
  elapsed: 0,
  scrollX: 0
};

// Player
const player = {
  x: 100,
  y: GROUND_Y - 120,
  w: 120,
  h: 120,
  vy: 0,
  gravity: 0.8,
  jumpPower: -20, // Much stronger jump for bigger character
  grounded: true,
  animFrame: 0
};

// Game objects
let obstacles = [];
let particles = [];
let confetti = [];
let finishLine = null;
let messageTypeIndex = 0;

// Celebration state
let celebration = {
  playerX: 0,
  partnerX: W + 100,
  playerSize: 120,
  partnerSize: 120,
  showGift: false,
  giftOpened: false,
  charactersVisible: true,
  celebrationPhase: 'moving' // 'moving', 'celebrating', 'finished'
};

const OBSTACLE_COUNT = 5;

// Input handling
const keys = {};

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  handleInput(e.code);
});

document.addEventListener('keyup', e => {
  keys[e.code] = false;
});

canvas.addEventListener('click', () => {
  handleInput('click');
});

function handleInput(input) {
  switch(gameState.current) {
    case 'start':
      if (input === 'Space' || input === 'Enter' || input === 'click') {
        startGame();
      }
      break;
    case 'playing':
      if (input === 'Space' || input === 'ArrowUp' || input === 'click') {
        jump();
      }
      break;
    case 'gameover':
      if (input === 'Enter' || input === 'click') {
        resetGame();
      }
      break;
    case 'celebration':
      if (celebration.showGift && !celebration.giftOpened && (input === 'Enter' || input === 'click')) {
        openGift();
      }
      break;
  }
}

function startGame() {
  gameState.current = 'playing';
  gameState.score = 0;
  gameState.scrollX = 0;
  
  // Reset player
  player.x = 100;
  player.y = GROUND_Y - 120;
  player.vy = 0;
  player.grounded = true;
  
  // Create obstacles
  obstacles = [];
  let x = W + 400; // More space before first obstacle
  for (let i = 0; i < OBSTACLE_COUNT; i++) {
    obstacles.push({
      x: x,
      y: GROUND_Y - 30, // Lower obstacles so they're easier to jump over
      w: 30, // Even smaller width
      h: 30, // Even smaller height
      type: i % 3,
      passed: false
    });
    x += 500 + Math.random() * 200; // Much more space between obstacles
  }
  
  finishLine = { x: x + 100 };
  
  updateHUD('Playing', '0%', '0');
  updateControls('Press SPACE or tap to jump');
  
  gameLoop();
}

function resetGame() {
  gameState.current = 'start';
  gameState.elapsed = 0;
  particles = [];
  confetti = [];
  celebration = {
    playerX: 0,
    partnerX: W + 100,
    playerSize: 120,
    partnerSize: 120,
    showGift: false,
    giftOpened: false,
    charactersVisible: true,
    celebrationPhase: 'moving'
  };
  messageTypeIndex = 0;
  
  updateHUD('Ready to Play', '0%', '0');
  updateControls('Press SPACE or tap to start');
  
  draw();
}

function jump() {
  if (player.grounded) {
    player.vy = player.jumpPower;
    player.grounded = false;
    
    // Add jump particle effect
    for (let i = 0; i < 5; i++) {
      particles.push({
        x: player.x + player.w/2,
        y: player.y + player.h,
        vx: (Math.random() - 0.5) * 4,
        vy: -Math.random() * 3,
        life: 20,
        maxLife: 20,
        color: colors.accent
      });
    }
  }
}

function gameLoop() {
  if (gameState.current === 'playing' || gameState.current === 'celebration' || gameState.current === 'message') {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  } else {
    draw();
  }
}

function update() {
  gameState.elapsed++;
  
  // Update player physics
  player.vy += player.gravity;
  player.y += player.vy;
  
  if (player.y >= GROUND_Y - player.h) {
    player.y = GROUND_Y - player.h;
    if (!player.grounded) {
      // Landing particles
      for (let i = 0; i < 3; i++) {
        particles.push({
          x: player.x + player.w/2,
          y: player.y + player.h,
          vx: (Math.random() - 0.5) * 2,
          vy: -Math.random() * 2,
          life: 15,
          maxLife: 15,
          color: colors.ground
        });
      }
    }
    player.vy = 0;
    player.grounded = true;
  }
  
  player.animFrame = gameState.elapsed * 0.1;
  
  // Scroll world
  if (gameState.current === 'playing') {
    gameState.scrollX += 4;
    gameState.score += 1;
  }
  
  // Check collisions
  if (gameState.current === 'playing') {
    for (let obstacle of obstacles) {
      const screenX = obstacle.x - gameState.scrollX;
      
      if (!obstacle.passed && screenX + obstacle.w < player.x) {
        obstacle.passed = true;
      }
      
      if (isColliding(player, {x: screenX, y: obstacle.y, w: obstacle.w, h: obstacle.h})) {
        gameOver();
        return;
      }
    }
    
    // Check finish line
    const finishScreenX = finishLine.x - gameState.scrollX;
    if (finishScreenX < player.x + player.w) {
      startCelebration();
      return;
    }
  }
  
  // Update celebration
  if (gameState.current === 'celebration') {
    // Move characters to center
    const targetPlayerX = W * 0.3;
    const targetPartnerX = W * 0.6;
    
    if (celebration.playerX < targetPlayerX) {
      celebration.playerX += 3;
      player.x = celebration.playerX;
    }
    
    if (celebration.partnerX > targetPartnerX) {
      celebration.partnerX -= 3;
    }
    
    // Show gift after characters are positioned
    if (!celebration.showGift && 
        Math.abs(celebration.playerX - targetPlayerX) < 10 && 
        Math.abs(celebration.partnerX - targetPartnerX) < 10) {
      setTimeout(() => {
        celebration.charactersVisible = false;
        celebration.showGift = true;
        updateControls('Press ENTER or tap gift to open');
      }, 2000);
    }
  }
  
  // Update particles
  updateParticles();
  
  // Update progress
  const passedObstacles = obstacles.filter(o => o.passed).length;
  gameState.progress = Math.floor((passedObstacles / OBSTACLE_COUNT) * 100);
  
  if (gameState.current === 'playing') {
    updateHUD('Playing', gameState.progress + '%', gameState.score.toString());
  }
}

function updateParticles() {
  // Update regular particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
  
  // Update confetti
  for (let i = confetti.length - 1; i >= 0; i--) {
    const c = confetti[i];
    c.x += c.vx;
    c.y += c.vy;
    c.rotation += c.rotSpeed;
    
    if (c.y > H + 10) {
      confetti.splice(i, 1);
    }
  }
}

function startCelebration() {
  gameState.current = 'celebration';
  celebration.playerX = player.x;
  celebration.celebrationPhase = 'moving';
  
  updateHUD('Celebration!', '100%', gameState.score.toString());
  updateControls('Congratulations!');
  
  // Create confetti
  for (let i = 0; i < 50; i++) {
    confetti.push({
      x: Math.random() * W,
      y: -Math.random() * H,
      vx: (Math.random() - 0.5) * 3,
      vy: 2 + Math.random() * 3,
      rotation: 0,
      rotSpeed: (Math.random() - 0.5) * 0.2,
      color: [colors.player, colors.partner, colors.accent][i % 3],
      size: 6 + Math.random() * 4
    });
  }
}

function openGift() {
  celebration.giftOpened = true;
  celebration.showGift = false;
  gameState.current = 'message';
  messageTypeIndex = 0;
  
  updateHUD('Birthday Message', '100%', gameState.score.toString());
  updateControls('Enjoy your special message!');
  
  // Type out message (and show restart instruction when finished)
  const typeMessage = () => {
    if (messageTypeIndex < BIRTHDAY_MESSAGE.length) {
      messageTypeIndex++;
      setTimeout(typeMessage, 50);
    } else {
      // typing finished â€” show hint to restart
      updateControls('Press ENTER or tap to restart');
    }
  };
  
  typeMessage();
  // Ensure the animation loop is running so the typing updates are drawn
  requestAnimationFrame(gameLoop);
}

function gameOver() {
  gameState.current = 'gameover';
  updateHUD('Game Over', gameState.progress + '%', gameState.score.toString());
  updateControls('Press ENTER or tap to restart');
}

function isColliding(a, b) {
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

function draw() {
  // Clear canvas
  ctx.clearRect(0, 0, W, H);
  
  // Draw sky
  const skyGradient = ctx.createLinearGradient(0, 0, 0, H);
  skyGradient.addColorStop(0, colors.sky);
  skyGradient.addColorStop(1, colors.skyBottom);
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, W, H);
  
  // Draw ground
  const groundGradient = ctx.createLinearGradient(0, GROUND_Y, 0, H);
  groundGradient.addColorStop(0, colors.ground);
  groundGradient.addColorStop(1, colors.groundDark);
  ctx.fillStyle = groundGradient;
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  
  // Draw game objects
  if (gameState.current === 'playing' || gameState.current === 'celebration') {
    drawObstacles();
    drawFinishLine();
  }
  
  drawPlayer();
  
  if (gameState.current === 'celebration' && celebration.charactersVisible) {
    drawPartner();
  }
  
  drawParticles();
  drawConfetti();
  
  if (celebration.showGift) {
    drawGift();
  }
  
  drawUI();
  
  if (gameState.current === 'message') {
    drawBirthdayMessage();
  }
}

function drawObstacles() {
  const obstacleEmojis = ['ðŸŽ‚', 'ðŸŽ', 'ðŸŽˆ'];
  
  for (let obstacle of obstacles) {
    const screenX = obstacle.x - gameState.scrollX;
    
    if (screenX > -100 && screenX < W + 100) {
      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(screenX + 5, obstacle.y + obstacle.h - 5, obstacle.w, 8);
      
      // Obstacle body
      ctx.fillStyle = colors.obstacle;
      drawRoundedRect(screenX, obstacle.y, obstacle.w, obstacle.h, 8);
      
      // Emoji
      ctx.font = '48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(obstacleEmojis[obstacle.type], screenX + obstacle.w/2, obstacle.y + obstacle.h * 0.7);
    }
  }
}

function drawFinishLine() {
  // Only draw if celebration hasn't started
  if (gameState.current !== 'celebration' && gameState.current !== 'message') {
    const screenX = finishLine.x - gameState.scrollX;
    
    if (screenX > -100 && screenX < W + 100) {
      // Flag pole
      ctx.fillStyle = colors.dark;
      ctx.fillRect(screenX, GROUND_Y - 100, 4, 100);
      
      // Flag
      ctx.fillStyle = colors.accent;
      drawRoundedRect(screenX + 4, GROUND_Y - 100, 60, 30, 4);
      
      ctx.fillStyle = colors.dark;
      ctx.font = 'bold 12px Inter';
      ctx.textAlign = 'center';
      ctx.fillText('FINISH', screenX + 34, GROUND_Y - 82);
    }
  }
}

function drawPlayer() {
  let size = player.w;
  let x = player.x;
  let y = player.y;
  
  // During celebration, use celebration sizing and positioning
  if (gameState.current === 'celebration') {
    size = celebration.playerSize;
    x = celebration.playerX;
    y = GROUND_Y - size;
    
    // Add bouncing during celebration phase - BOTH characters celebrate
    if (celebration.celebrationPhase === 'celebrating') {
      y += Math.sin(gameState.elapsed * 0.3) * 15; // Bigger bounce for celebration
    }
  } else {
    // Normal bouncing during gameplay
    const bounce = player.grounded ? Math.sin(player.animFrame) * 3 : 0;
    y = player.y + bounce;
  }
  
  // Shadow (adjust for size)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.fillRect(x + 5, GROUND_Y - 5, size, 8);
  
  // Try to draw PNG image first
  if (playerImg.complete && playerImg.naturalWidth > 0) {
    ctx.drawImage(playerImg, x, y, size, size);
  } else {
    // Fallback: Clean modern character design
    ctx.fillStyle = colors.player;
    drawRoundedRect(x, y, size, size, size * 0.2);
    
    const scale = size / 120; // Scale features based on new base size
    
    // Simple face
    ctx.fillStyle = colors.white;
    ctx.beginPath();
    ctx.arc(x + 35 * scale, y + 35 * scale, 12 * scale, 0, Math.PI * 2);
    ctx.arc(x + 85 * scale, y + 35 * scale, 12 * scale, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = colors.dark;
    ctx.beginPath();
    ctx.arc(x + 35 * scale, y + 35 * scale, 6 * scale, 0, Math.PI * 2);
    ctx.arc(x + 85 * scale, y + 35 * scale, 6 * scale, 0, Math.PI * 2);
    ctx.fill();
    
    // Smile
    ctx.strokeStyle = colors.dark;
    ctx.lineWidth = 3 * scale;
    ctx.beginPath();
    ctx.arc(x + 60 * scale, y + 75 * scale, 20 * scale, 0, Math.PI);
    ctx.stroke();
  }
}

function drawPartner() {
  if (!celebration.charactersVisible) return;
  
  const x = celebration.partnerX;
  const size = celebration.partnerSize;
  let y = GROUND_Y - size;
  
  // Add bouncing during celebration phase - BOTH characters celebrate
  if (celebration.celebrationPhase === 'celebrating') {
    y += Math.sin((gameState.elapsed + 20) * 0.3) * 12; // Different offset and bigger bounce
  } else {
    y += Math.sin(gameState.elapsed * 0.1) * 3;
  }
  
  // Shadow (adjust for size)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.fillRect(x + 5, GROUND_Y - 5, size, 8);
  
  // Try to draw PNG image first
  if (partnerImg.complete && partnerImg.naturalWidth > 0) {
    ctx.drawImage(partnerImg, x, y, size, size);
  } else {
    // Fallback: Clean modern character design
    ctx.fillStyle = colors.partner;
    drawRoundedRect(x, y, size, size, size * 0.2);
    
    const scale = size / 120; // Scale features based on new base size
    
    // Simple face
    ctx.fillStyle = colors.white;
    ctx.beginPath();
    ctx.arc(x + 35 * scale, y + 35 * scale, 12 * scale, 0, Math.PI * 2);
    ctx.arc(x + 85 * scale, y + 35 * scale, 12 * scale, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = colors.dark;
    ctx.beginPath();
    ctx.arc(x + 35 * scale, y + 35 * scale, 6 * scale, 0, Math.PI * 2);
    ctx.arc(x + 85 * scale, y + 35 * scale, 6 * scale, 0, Math.PI * 2);
    ctx.fill();
    
    // Smile
    ctx.strokeStyle = colors.dark;
    ctx.lineWidth = 3 * scale;
    ctx.beginPath();
    ctx.arc(x + 60 * scale, y + 75 * scale, 20 * scale, 0, Math.PI);
    ctx.stroke();
  }
}

function drawGift() {
  const x = W/2 - 40;
  const y = GROUND_Y - 120;
  const bounce = Math.sin(gameState.elapsed * 0.1) * 5;
  
  // Gift shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.fillRect(x + 5, GROUND_Y - 5, 80, 8);
  
  // Try to draw PNG image first
  if (giftImg.complete && giftImg.naturalWidth > 0) {
    ctx.drawImage(giftImg, x, y + bounce, 80, 80);
  } else {
    // Fallback: Clean modern gift box
    ctx.fillStyle = colors.accent;
    drawRoundedRect(x, y + bounce, 80, 80, 8);
    
    // Ribbon
    ctx.fillStyle = colors.player;
    ctx.fillRect(x + 35, y + bounce, 10, 80);
    ctx.fillRect(x, y + bounce + 35, 80, 10);
    
    // Bow
    ctx.fillStyle = colors.player;
    ctx.beginPath();
    ctx.arc(x + 40, y + bounce + 20, 12, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Sparkles around gift (always show regardless of PNG)
  for (let i = 0; i < 6; i++) {
    const angle = (gameState.elapsed * 0.05 + i / 6) * Math.PI * 2;
    const sparkleX = x + 40 + Math.cos(angle) * 50;
    const sparkleY = y + 40 + Math.sin(angle) * 30 + bounce;
    
    ctx.fillStyle = colors.white;
    ctx.beginPath();
    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Instructions
  ctx.fillStyle = colors.dark;
  ctx.font = 'bold 16px Inter';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸŽ Tap to open!', x + 40, y + 110);
}

function drawParticles() {
  for (let particle of particles) {
    const alpha = particle.life / particle.maxLife;
    ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawConfetti() {
  for (let piece of confetti) {
    ctx.save();
    ctx.translate(piece.x, piece.y);
    ctx.rotate(piece.rotation);
    ctx.fillStyle = piece.color;
    ctx.fillRect(-piece.size/2, -piece.size/2, piece.size, piece.size);
    ctx.restore();
  }
}

function drawUI() {
  ctx.fillStyle = colors.dark;
  ctx.font = 'bold 32px Inter';
  ctx.textAlign = 'center';
  
  if (gameState.current === 'start') {
    const cardY = H/2 - 80;
    
    // Semi-transparent card
    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    drawRoundedRect(W/2 - 200, cardY, 400, 160, 16);
    
    ctx.fillStyle = colors.dark;
    ctx.font = 'bold 28px Inter';
    ctx.fillText('ðŸŽ® Birthday Adventure', W/2, cardY + 40);
    
    ctx.font = '16px Inter';
    ctx.fillText('Jump over obstacles to reach the finish!', W/2, cardY + 70);
    
    ctx.font = 'bold 18px Inter';
    ctx.fillStyle = colors.player;
    ctx.fillText('Press SPACE or tap to start', W/2, cardY + 110);
    
  } else if (gameState.current === 'gameover') {
    const cardY = H/2 - 60;
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    drawRoundedRect(W/2 - 150, cardY, 300, 120, 16);
    
    ctx.fillStyle = colors.dark;
    ctx.fillText('Game Over!', W/2, cardY + 40);
    
    ctx.font = 'bold 18px Inter';
    ctx.fillStyle = colors.player;
    ctx.fillText('Press ENTER to try again', W/2, cardY + 80);
  }
}

function drawBirthdayMessage() {
  const message = BIRTHDAY_MESSAGE.substring(0, messageTypeIndex);

  // Background overlay
  ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
  ctx.fillRect(0, 0, W, H);

  // Message box
  const boxWidth = W * 0.7;
  const boxHeight = H * 0.5;
  const boxX = (W - boxWidth) / 2;
  const boxY = (H - boxHeight) / 2;
  ctx.fillStyle = "#ffffff";
  ctx.strokeStyle = colors.accent;
  ctx.lineWidth = 4;
  drawRoundedRect(boxX, boxY, boxWidth, boxHeight, 20);

  // Message text (typing effect)
  ctx.fillStyle = colors.dark;
  ctx.font = "20px Inter";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  const words = message.split(" ");
  let line = "";
  let y = boxY + 40;
  const lineHeight = 28;
  const maxLineWidth = boxWidth - 40;

  for (let i = 0; i < words.length; i++) {
    const testLine = line + words[i] + " ";
    const testWidth = ctx.measureText(testLine).width;
    if (testWidth > maxLineWidth && i > 0) {
      ctx.fillText(line, boxX + boxWidth / 2, y);
      line = words[i] + " ";
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, boxX + boxWidth / 2, y);

  // Footer
  ctx.font = "bold 18px Inter";
  ctx.fillStyle = colors.accent;
  ctx.fillText("You are the bestest <3", boxX + boxWidth / 2, boxY + boxHeight - 40);
}

function drawRoundedRect(x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

function updateHUD(status, progress, score) {
  document.getElementById('status').textContent = status;
  document.getElementById('progress').textContent = progress;
  document.getElementById('score').textContent = score;
}

function updateControls(text) {
  document.getElementById('controls').textContent = text;
}

// Create floating particles
function createFloatingParticles() {
  const container = document.querySelector('.floating-particles');
  
  setInterval(() => {
    if (Math.random() > 0.8) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = Math.random() * 100 + '%';
      particle.style.animationDuration = (6 + Math.random() * 4) + 's';
      particle.style.animationDelay = Math.random() * 2 + 's';
      
      container.appendChild(particle);
      
      setTimeout(() => {
        if (particle.parentNode) {
          particle.parentNode.removeChild(particle);
        }
      }, 10000);
    }
  }, 500);
}

// Initialize game
resetGame();
createFloatingParticles();

// Responsive canvas
function resizeCanvas() {
  const container = document.querySelector('.game-container');
  const containerRect = container.getBoundingClientRect();
  const maxWidth = Math.min(containerRect.width, 1000);
  const aspectRatio = 400 / 1000;
  
  canvas.style.width = maxWidth + 'px';
  canvas.style.height = (maxWidth * aspectRatio) + 'px';
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();
</script>
</body>
</html>